"""Agent processing logic for WebSocket messages"""

import asyncio
import logging

from google.genai.types import Content, Part


try:
    from google.genai.errors import ClientError
except ImportError:
    ClientError = None

from app.models.enrollment import EnrollmentUpdate
from app.models.websocket_messages import (
    AgentHandoverMessage,
    AgentMessage,
    AgentProcessingEndMessage,
    AgentProcessingStartMessage,
    CheckpointUpdateMessage,
    ErrorMessage,
    SessionClosedMessage,
)


logger = logging.getLogger(__name__)


class AgentProcessor:
    def __init__(self, manager, context):
        self.manager = manager
        self.context = context

    async def process_user_message(self, session_id: str, user_message: str):
        """Process user message through agent flow"""
        logger.info(f"Starting agent processing for session {session_id}")

        try:
            await self.manager.send_message(session_id, AgentProcessingStartMessage())

            session_before = self.context.adk_session
            completed_checkpoints_before = (
                session_before.state.get("completed_checkpoints", [])
                if session_before and session_before.state
                else []
            )

            wrapper_transferred = await self._run_agent(session_id, user_message)

            session_after = await self.context.refresh_adk_session(session_id)

            if wrapper_transferred:
                await self._handle_mission_completion(
                    session_id,
                    session_after.state.get("completed_checkpoints", []) if session_after else [],
                )
                await self.manager.send_message(session_id, AgentProcessingEndMessage())
                return

            if session_after and session_after.state:
                completed_checkpoints_after = session_after.state.get("completed_checkpoints", [])
                if len(completed_checkpoints_after) > len(completed_checkpoints_before):
                    await self._update_checkpoint_progress(session_id, completed_checkpoints_after)

            await self._check_and_mark_completed(session_id)
            await self.manager.send_message(session_id, AgentProcessingEndMessage())

        except Exception as e:
            logger.error(f"Error in agent processing: {e}", exc_info=True)
            await self.manager.send_message(session_id, AgentProcessingEndMessage())
            await self.manager.send_message(
                session_id, ErrorMessage(message=f"Processing error: {str(e)}")
            )

    async def _run_agent(self, session_id: str, user_message: str) -> bool:
        """Run agent and process events, returns True if wrapper transferred"""
        user_content = Content(parts=[Part(text=user_message)])
        wrapper_transferred = False

        try:
            event_generator = self.manager.runner.run(
                user_id=self.context.user_id, session_id=session_id, new_message=user_content
            )

            event_count = 0
            for event in event_generator:
                event_count += 1
                try:
                    transfer_result = await self._handle_agent_transfer(event, session_id)
                    if transfer_result == "close":
                        wrapper_transferred = True
                        logger.info(f"Wrapper transfer detected for session {session_id}")

                    await self._send_agent_message(event, session_id)

                except Exception as event_error:
                    logger.error(
                        f"Error processing event #{event_count}: {event_error}", exc_info=True
                    )
                    continue

            if event_count == 0:
                logger.warning(f"No events generated by runner for session {session_id}")

        except (RuntimeError, SystemError) as e:
            error_msg = str(e).lower()
            if any(kw in error_msg for kw in ["asyncio", "thread", "event loop"]):
                logger.error(f"Async/threading error: {e}", exc_info=True)
                raise ValueError(
                    "Internal processing error occurred. Please try again in a moment."
                ) from e
            raise

        return wrapper_transferred

    async def _handle_agent_transfer(self, event, session_id: str):
        """Handle agent transfer events"""
        if not hasattr(event, "actions") or not event.actions:
            return False
        if not hasattr(event.actions, "transfer_to_agent") or not event.actions.transfer_to_agent:
            return False

        transfer_target = event.actions.transfer_to_agent
        logger.info(f"Agent transfer to {transfer_target} for session {session_id}")

        if transfer_target == "lumina_wrapper_agent":
            return "close"

        await self.manager.send_message(
            session_id,
            AgentHandoverMessage(
                agent=transfer_target, message=f"Handing over to {transfer_target}..."
            ),
        )
        return True

    async def _send_agent_message(self, event, session_id: str):
        """Send agent message content to client"""
        if not hasattr(event, "author") or event.author == "user":
            return
        if not hasattr(event, "content") or not event.content:
            return
        if not hasattr(event.content, "parts") or not event.content.parts:
            return

        for part in event.content.parts:
            if hasattr(part, "text") and part.text:
                await self.manager.send_message(session_id, AgentMessage(message=part.text))

    async def _update_checkpoint_progress(self, session_id: str, completed_checkpoints: list[str]):
        """Update enrollment progress and send checkpoint update"""
        try:
            mission = self.context.mission
            total_checkpoints = (
                len(mission.byte_size_checkpoints) if mission.byte_size_checkpoints else 1
            )
            progress = min(100.0, (len(completed_checkpoints) / total_checkpoints) * 100.0)

            enrollment_update = EnrollmentUpdate(
                progress=progress, completed_checkpoints=completed_checkpoints
            )
            self.context.enrollment_service.update_enrollment(
                self.context.user_id, self.context.mission_id, enrollment_update
            )

            await self.manager.send_message(
                session_id,
                CheckpointUpdateMessage(
                    completed_checkpoints=completed_checkpoints, progress=progress
                ),
            )
        except Exception as e:
            logger.error(f"Failed to update checkpoint progress: {e}", exc_info=True)

    async def _handle_mission_completion(self, session_id: str, completed_checkpoints: list[str]):
        """Handle mission completion"""
        try:
            mission = self.context.mission
            total_checkpoints = (
                len(mission.byte_size_checkpoints) if mission.byte_size_checkpoints else 1
            )

            if len(completed_checkpoints) < total_checkpoints:
                completed_checkpoints = (mission.byte_size_checkpoints or []).copy()

            enrollment_update = EnrollmentUpdate(
                progress=100.0, completed_checkpoints=completed_checkpoints
            )
            self.context.enrollment_service.update_enrollment(
                self.context.user_id, self.context.mission_id, enrollment_update
            )

            self.context.enrollment_session_log_service.mark_session_completed(
                self.context.enrollment_session_log.id
            )
        except Exception as e:
            logger.error(f"Failed to complete mission: {e}", exc_info=True)

        await self.manager.send_message(
            session_id,
            SessionClosedMessage(message="Congratulations! You've completed the mission!"),
        )
        await asyncio.sleep(0.1)

        websocket = self.manager.active_connections.get(session_id)
        if websocket:
            try:
                await websocket.close()
            except Exception:
                pass
        self.manager.disconnect(session_id)

    async def _check_and_mark_completed(self, session_id: str):
        """Check if all checkpoints completed and mark session as completed"""
        session = self.context.adk_session
        if not session or not session.state:
            return

        if session.state.get("current_checkpoint_index", -1) == -1:
            if self.context.enrollment_session_log.status != "completed":
                self.context.enrollment_session_log_service.mark_session_completed(
                    self.context.enrollment_session_log.id
                )
